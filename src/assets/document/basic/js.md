## 简介
- 每个浏览器标签页都是其自身用来运行代码的独立容器("运行环境")。
- JS运行次序：**自上而下顺序执行代码**。
- JS是轻量型解释型语言，几乎所有JS转换器都运用了一种叫做`“即时编译(just-in-time compiling)”`的技术，当JS源码执行时，它会被编译成二进制的格式，使代码运行速度更快。
- JS是客户端代码，由浏览器来运行并展示
- 动态类型语言，通过按需生成新内容来更新 web 页面 / 应用，使得不同环境下显示不同内容。
- 内部JS和外部JS
- async和defer

## 常见名称
- 变量：用于保存数据.变量本质上是值(例如数字或字符串)的名称。——`let关键字创建`
- 常量：也用于对值进行命名，但不像变量，无法修改。——`const关键字创建`
- 赋值：使用`=`为变量/常量赋值
- 函数`Function`：可复用的代码块，可以一次编写，反复运行。`function关键字定义`——js一等公民
- 运算符：执行比较、做数学运算、链接字符串... => `=、+、-、*、/、+=、===、!==、<、>`
- 条件语句if/else/else if
- 事件`Event`
- 循环`Loop`
- 对象`Object`

## js错误
代码错误主页分两种：
1. 语法错误：代码中存在拼写错误，将导致程序完全或部分不能运行，通常你会收到一些出错信息。
2. 逻辑错误：有些代码语法虽正确，但执行结果和预期相悖，这里便存在着逻辑错误。

### 函数-可复用代码块
- 函数和方法
  - 内置浏览器函数并不是函数，它们是方法
  - 区别：方法是在对象内定义的函数。
  - 浏览器内置函数(方法)和变量(称为属性)存储在结构化对象内，以使代码更高效、易于处理.
- 自定义函数`function xxx() {}`
- 调用函数`xxx();`
- 匿名函数`function () {}`
  - 通常和事件处理程序一起使用
  - 将匿名函数分配为变量的值

>匿名函数也称为函数表达式。函数表达式与函数声明有一些区别。函数声明会进行声明提升，而函数表达式不会。

>参数有时称为参数（`arguments`），属性（`properties`）或甚至属性（`attributes`）

## 事件
事件是您在编程时系统内发生的动作或者发生的事情

- 每个可用的事件都会有一个**事件处理器**,也就是事件触发时会运行的代码块。
- 当我们定义了一个用于回应事件被激发的代码块时——**注册了一个事件处理器**。 
- 事件处理器有时也被叫做**事件监听器**

>网络事件并不是JS语言的核心——它们被定义成内置于浏览器的`JavaScript APIs`

### 事件对象
>事件处理函数内部，固定指定名称的参数`event`,被称为事件对象，他被自动传递给事件处理函数，以提供额外的功能和信息。

- 阻止默认行为`e.preventDefault();`
- 事件冒泡及捕获
  - 一个事件发生在具有父元素的元素上时，浏览器运行捕获阶段和冒泡阶段
  - `stopPropagation();`阻止冒泡

### 事件委托
>冒泡允许我们利用事件委托——想在大量子元素中单击任何一个都可以运行一段代码，可以将事件监听器设置在其父节点上，并让子节点上发生的事件冒泡到父节点上

## 对象
>对象是一个包含相关数据和方法的集合(通常由一些变量和函数组成，我们称为对象里面的属性和方法)

- 对象由许多成员组成，每一个成员都拥有一个名字和一个值，每一个名字/值(name/value)对被逗号分隔开，并且名字和值之间由冒号(:)分隔`name: value,`

- `对象的字面量`: 手动的写出对象的内容来创建一个对象

- 点表示法`person.name`，使用点表示法(`dot notation`)来访问对象的属性和方法。对象的名字表现为一个命名空间(namespace)。
  - 子命名空间

- 括号表示法`person['name']`
>关联了值的名字，不是索引去选择元素。所以对象有时被称为关联数组(`associative array`)。对象做到了字符串到值的映射，数组做到的是数字到值的映射。

### 对象原型
- 原型链：JavaScript中所有的对象都有一个内置属性，称为它的`prototype(原型)`.而原型本身也是一个对象，所以原型对象也有它的原型，这样构成原型链。终止于`null`。(当你试图访问一个对象的属性时：如果在对象本身中找不到该属性，就会在原型中搜索该属性。)

>指向对象原型的属性并不是`prototype`。而是`__proto__`。访问对象原型的标准方法是`Object.getPrototypeOf()`

- 属性遮蔽(先调用对象上的、然后才是原型)
- 设置原型
  - `Object.create()`: 创建一个新对象(obj)，允许指定一个被用作新对象(obj)原型的对象。
  - 构造函数
    - 自有属性：直接在对象中定义的属性
    - `Object.assign(target, source)`: 静态方法。将一个或多个源对象中所有可枚举的自有属性复制到目标对象，并返回修改后的目标对象。
  
- 检查一个属性是否是自有属性
  - `Object.hasOwnProperty()`: 非静态方法 => `obj.hasOwnProperty('name');`
  - `Object.hasOwn()`: 静态方法 => `Object.hasOwn(obj, 'name');`

- 原型和继承

## 面向对象
>三大主要概念: **类与实例、继承、封装**

- 类只是一种用于创建具体对象的模板
- 实例是通过类创建出来的
  - 构造函数
  - 属性
  - 方法

- 继承: 用某种特别的方式共享类中相同属性的声明
  - 父类(超类)
  - 子类
>当一个方法拥有相同的函数名，但是在不同的类中可以具有不同的实现时，称这一特性为**多态**
>当一个方法在子类中替换了父类中中的实现时，称为子类**重写/重载**(`override`)了父类中的实现

- 封装：保持对象内部状态的私有性、明确划分对象的公共接口和内部状态，这些特性称之为封装（`encapsulation`）

## 类
### 基础
- `class`关键字声明一个类
- 需要属性的声明 -> 声明和初始化可以同时进行`name = ''`
- 构造函数，用于初始化对象（如果不需要初始化内容，可以省略构造函数）
  - 创建一个新对象
  - 将this绑定到该对象
  - 执行构造函数中的代码
  - 返回新对象
- 方法

### 继承
- `extends`关键字来声明
- 构造函数
  - 使用super调用父类构造函数
  - 必须先使用`super()`来调用父类构造函数，并传递父类构造函数期望的任何参数

### 封装
>私有属性/方法在外部使用会抛出错误
>私有数据属性必须在类的声明中声明，而且其名称需以 # 开头

- 私有属性例如：`#year`
- 私有方法例如: `#sayHello()`

## JSON
>按照JS对象语法的数据格式，但它独立于JS。

- 作为对象: 用于解读JSON中的数据
- 作为字符串: 用于网络传输JSON数据

JSON对象可以被存储在它自己的文件中，基本上就是一个文本文件，扩展名为`.json`，`MIME type(application/json)`

>`MIME type` （现在称为“媒体类型 (`media type`)”，但有时也是“内容类型 (`content type`)”）是**指示文件类型的字符串**，与文件一起发送（例如，一个声音文件可能被标记为 audio/ogg ，一个图像文件可能是 image/png ）。它与传统 Windows 上的文件扩展名有相同目的。

注意事项
- JSON是一种纯数据格式，只包含属性，没有方法
- JSON要求字符串和属性名称周围使用双引号.单引号无效
- 甚至一个错位的逗号或分号就可以导致 JSON 文件出错
- JSON 可以将任何标准合法的 JSON 数据格式化保存，不只是数组和对象。
- 与 JavaScript 代码中对象属性可以不加引号不同，JSON 中只有带引号的字符串可以用作属性。

### 对象和文本间转换
- `parse()`: 以文本字符串形式接受JSON对象作为参数，返回相应对象
- `stringify()`: 接受一个对象作为参数，返回对应的JSON字符串.

## 异步JS
- 同步：浏览器按住从上至下的顺序一行一行执行程序。上一行完成后才会执行下一行。

当同步任务需要很长时间怎么办？
>我们的程序没有反应，用户不能进行输入、点击等任何其他事情。

**事件处理程序**
>是异步编程的一种形式：在事件发生时才被调用(而不是立即调用).

**回调**
>事件处理程序是一种特殊类型的回调函数。而回调函数则是一个被传递到另一个函数中的会在适当时候被调用的函数。

当回调函数本身需要调用其他同样接受回调函数的函数时，基于回调的代码会变得难以理解。`回调地狱`或`厄运金字塔(缩进看起来像一个金字塔的侧面)`

### Promise
>现代JS异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象。

**Promise术语**
- 三种状态：`pending(待定)`、`fulfilled(已兑现)`、`rejected(已拒绝)`
- 有时用`settled(已敲定)`来同时表示fulfilled和rejected

### async/await
可以在调用一个返回 `Promise` 的函数之前使用 `await` 关键字——代码会在该点等待，直到Promise被完成。——**使得我们可以向编写同步代码那样编写异步函数**

### workers
- js是单线程的，同一时间只能做一件事情，所以如果它在等待我们的长期运行的同步任务调用返回，他就不能做其他事情。

- `workers`给了在不同线程中运行某些人物的能力。但这需要付出代价(永远也不知道你的线程什么时候会被挂起，其他线程将会得到运行的机会, 因此，如果两个线程都可以访问相同的变量，那么变量就有可能在任何时候发生意外的变化。)

>**你的主代码和worker代码永远不能直接访问彼此的变量。**worker代码和主代码运行在完全分离的环境中，只能通过相互发消息来交互。这意味着 `workers` 不能访问 DOM（窗口、文档、页面元素等等）

**`workers`类型**
- `dedicated workders`: 由一个脚本实例使用
- `shared workers`： 运行在不同窗口中的多个不同脚本共享
- `service workers`： 行为像代理服务器，缓存资源以便于web应用程序可以在用户离线时工作。是**渐进式web应用**的关键组件。

```js
// 主线程
// 1、创建worker
const worker = require("xxx.js");
// 2、执行某些操作，向worker发送消息
worker.postMessage({
  command: "generate",
  quota: 100000
});
// 3、监听worker给主线程发送的消息
window.addEventListener("message", message => {
  //message.data
});

// workder
// 1、监听主线程消息
window.addEventListener("message", message = {
  // xxx(message.data)
});

function xxx(val) {
  //....

  //完成后给主线程发送一条包含我们生成数据的消息
  postMessage(newVal);
}
```

## 客户端Web API
>**API(应用程序接口, `Application Programming Interface`)**是基于编程语言构建的结构，使开发人员更容易地创建复杂的功能。它们抽象了复杂的代码，并提供一些简单的接口规则直接使用。

- 浏览器API内置于与浏览器内
- 第三方API缺省情况下不会内置于浏览器中，通常必须在Web中的某个地方获取代码和信息。

### JS、API和其它JS工具的关系
- `JavaScript`: 内置于浏览器的高级脚本语言，用来实现Web页面/应用中的功能.
- `客户端API`: 内置于浏览器的结构程序，位于JavaScript顶部，使开发人员能更容易实现功能
- `第三方API`: 置于第三方普通的结构程序，使得开发人员能使用那些平台的某些功能.
- `JavaScript库`: 通常是包含具有特定功能的一个或多个JavaScript文件。
- `JavaScript框架`: 从库开始的下一步，JavaScript 框架视图把 `HTML、CSS、JavaScript` 和其他安装的技术打包在一起，然后用来从头编写一个完整的 Web 应用。

### API如何工作
- 基于对象
- 有可识别的入口点
- 使用事件来处理状态的变化
- 在适当的地方有额外的安全机制

### 客户端存储
- 传统方法`cookies`: 唯一优势是得到了非常旧的浏览器支持。
- `Web Storage`: 用于存储和检索较小的、由名称和相应值组成的数据项。
  - `sessionStorage`: 浏览器打开者，就会一直保持，关闭时数据丢失
  - `localStorage`: 一直保存数据
  - `Storage.getItem()`、`Storage.setItem()`、`Storage.removeItem()`
- `IndexedDB`：为浏览器提供了一个完整的数据库系统来存储复杂的数据。
- `Cache API`: 存储特定HTTP请求的响应文件，对于存储离线网站这样的事情非常有用。